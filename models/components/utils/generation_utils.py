"""
Build the data generation types specified in the given config.

Two methods are used. 

The first method is to use the given text generation strategy (e.g. standard, beam search, etc)
to generate N data responses for a given input text, up till length L. The value model is then used
to evaluate the data responses generated by giving it a score. Sorting them by rank, the top R data
responses are then saved and extracted.

The second method is to use the given text generation strategy (e.g. standard, beam search, etc)
and use the given input text to build a Monte-Carlo Tree Search (MCTS) tree up to depth K. At 
each step, the value model is used to evaluate the data responses generated by giving it a score.
The best child node response is then selected and the MCTS tree is updated. This process is repeated 
till the end of the tree. Based on the tree, the top R data responses are then saved and extracted.
"""

from models.generators import build_generator

class StandardDataGenerator:
    """
    Standard data generation strategy
    """
    def __init__(self, model, value_model, generate_cfg, strategy_cfg, device):
        self.model = model
        self.value_model = value_model
        self.generate_cfg = generate_cfg
        self.strategy_cfg = strategy_cfg
        self.device = device

    def generate_data(self, input_text):
        """
        Generate data using the standard generation strategy
        """
        generator = build_generator(
            model=self.model,
            generate_cfg=self.generate_cfg,
            device=self.device
        )

        # generate the text
        generated_text = generator.default_generate(
            input_text=input_text ## TODO - any supporting prompts
        )

        # step value evaluation
        text = "".join(generated_text)
        value = self.value_model.evaluate(
            model_input=text,
            token=self.strategy_cfg["step_token"]
        )
        value = 1
        for v in value:
            value *= v

        return generated_text, value
    
class Node:
        """
        Node class for MCTS
        """
        def __init__(self, parent, value, text):
            self.parent = parent
            self.children = []
            self.value = value
            self.text = text
    
class MCTSDataGenerator:
    """
    Monte-Carlo Tree Search data generation strategy
    """
    def __init__(self, model, value_model, generate_cfg, strategy_cfg, device):
        self.model = model
        self.value_model = value_model
        self.generate_cfg = generate_cfg
        self.strategy_cfg = strategy_cfg
        self.device = device

    def generate_data(self, input_text):
        """
        Generate data using the MCTS generation strategy. Basically build a tree and select the best child node
        at each step.
        """
        root = Node(None, 0, input_text)
        nodes = [root]

        for _ in range(self.strategy_cfg["max_tree_depth"]):
            new_nodes = []
            for node in nodes:
                # expand the node
                child_prompts = self._generate_child_prompts(node.prompt, num_samples=self.strategy_cfg['max_child_nodes']) 
                for prompt in child_prompts:
                    child = Node(node, 0, prompt)
                    node.children.append(child)
                    new_nodes.append(child)
            # evaluate the nodes by assigning them a value
            self._score_nodes(new_nodes)
            # select the best child node
            best_child = self._select_best_child(node)
            nodes = [best_child]

        return self._stitch_responses(best_child)


    def _generate_child_prompts(self, prompt, num_samples):
        """
        Generate child prompts
        """
        generator = build_generator(
            model=self.model,
            generate_cfg=self.generate_cfg,
            device=self.device
        )

        child_prompts = []
        for _ in range(num_samples):
            generated_text = generator.default_generate(
                input_text=self.strategy_cfg["expansion_prompt"].format(prompt) ## !! TODO - check if this is buggy
            )
            generated_text = "".join(generated_text)
            child_prompts.append(generated_text)
        return child_prompts
    
    def _score_nodes(self, nodes):
        """
        Score the nodes
        """
        for node in nodes:
            node.value = self.value_model.evaluate(
                generated_text=node.text
            )

    def _select_best_child(self, node):
        """
        Select the best child node
        """
        best_child = None
        best_score = -1
        for child in node.children:
            if child.value > best_score:
                best_child = child
                best_score = child.value
        return best_child
    
    def _stitch_responses(self, node):
        """
        Stitch the responses together
        """
        responses = []
        value = 1
        while node is not None:
            responses.append(node.text)
            value *= node.value
            node = node.parent
        return responses[::-1], value ## reverse the responses



GENERATION_STRATEGIES = {
    "standard": lambda model, value_model, generate_cfg, strategy_cfg, device: StandardDataGenerator(model, value_model, generate_cfg, strategy_cfg, device),
    "mcts": lambda model, value_model, generate_cfg, strategy_cfg, device: MCTSDataGenerator(model, value_model, generate_cfg, strategy_cfg, device)
}

def get_generator_type(model, value_model, generate_cfg, strategy_cfg, device):
    """
    Get the generator type based on the strategy
    """
    return GENERATION_STRATEGIES[strategy_cfg['name']](
        model=model,
        value_model=value_model,
        generate_cfg=generate_cfg,
        strategy_cfg=strategy_cfg,
        device=device
    )